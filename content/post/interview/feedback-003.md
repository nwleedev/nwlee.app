---
title: 'Feedback 003'
description: '몰랐던 지식 정리'
date: 2022-01-24T00:15:18+09:00
image:
math:
license:
hidden: false
comments: true
draft: true
tags:
  [
    '액티비티',
    '프래그먼트',
    '생명주기',
    'Activity',
    'Fragment',
    'Exception',
    'SSL',
    'HTTPS',
    'TLS',
    '데이터베이스',
    '정규화',
    '세션',
    '쿠키',
    'Session',
    'Cookie',
    'Stateless',
    'Stateful',
    'OSI',
    'OSI 7 계층',
  ]
categories: ['피드백']
---

# 면접 피드백 003

## 액티비티의 정의

안드로이드 앱이 UI를 출력할 수 있도록 창을 제공하는 기본적인 구성요소이다. 보통 화면을 채우는 일에 사용되지만 다른 창 위에 작게 떠 있도록 할 수도 있다.

## 프래그먼트의 정의

앱 UI에서 재사용 가능한 컴포넌트이다. 자체 레이아웃을 정의 및 관리한다. 각 프래그먼트마다 수명 주기가 존재하며 사용자의 입력 또한 처리할 수 있다. 독립적으로 존재할 수 없고 액티비티나 다른 프래그먼트에서 출력해주도록 호스팅해야한다.

## 코루틴 포착되지 않은 예외 처리

안드로이드에서 네트워크 요청 및 기타 비동기 작업을 처리할 때 코루틴을 사용했다. 코루틴이 실행되는 동안 예상하지 못한 오류가 발생하면 타 코루틴 및 부모 코루틴까지 강제로 종료될 수 있다. 코틀린에서 하위 코루틴들은 각자에게 발생한 예외들을 상위 코루틴이 처리하도록 위임하기 때문이다. 포착되지 못한 예외사항이 발생했을 때 최상위 코루틴에서 예외사항을 처리하기 위해 CoroutineExceptionHandler를 사용할 수 있다.

#### 예시

```Kotlin
// BaseViewModel.kt
open class BaseViewModel : ViewModel() {
    private val coroutineExceptionHandler = CoroutineExceptionHandler { _, throwable ->
        throwable.printStackTrace()
    }

    protected val dispatcher = Dispatchers.Main + coroutineExceptionHandler
}

// 코루틴 실행
viewModelScope.launch(dispatcher) {
  // 비동기 작업
}
```

이 외에도 async 블록 내부에서 try catch 문을 작성하거나, SupervisorScope를 사용해서 예외를 막을 수도 있다. SupervisorScope는 예외가 발생했을 때 예외의 전파 범위를 제한하는 역할을 한다.

## HTTP, TLS

TLS: 전송 계층 암호화 프로토콜

HTTPS 통신 절차

공개 키 암호 방식

1. 브라우저가 서버로부터 서버의 SSL 인증서를 가져온다. 인증서 내부 발행자의 디지털 서명으로부터 상위 발행자의 인증서까지 차례로 검증한다. 최상위 인증기관의 인증서와 브라우저, OS의 인증서로 신뢰할 수 있는지 파악한다.
2. 브라우저는 통신용 공통 키를 생성한다. 서버 인증서에 첨부된 공개 키로 공통 키를 암호화하여 서버에 전송한다. 서버에서는 공개 티에 대응되는 개인 키로 공통 키를 확인할 수 있다.
3. 이후 브라우저와 서버는 공통 키로 메시지를 암호화하여 통신할 수 있다.

키 교환 암호 방식

키를 생성할 시드를 브라우저와 서버 각각 하나씩 만든다. 생성된 시드를 서로 교환 후 계산한 결과가 공통 키가 된다. 시드를 서로 교환할 때 공개 키 암호가 같이 사용된다.  
키 교환 알고리즘으로 생성된 공통 키는 동적으로 계산되고 따로 파일로 저장되지도 않는다.

## 네트워크 연결성

클라이언트와 서버가 요청과 응답을 서로 주고받는 동안 연결이 되어있다는 것을 증명할 수단이 있어야 한다. 연결 정보에는 연결한 사용자가 누구인지, 언제 접속했는지에 대한 정보가 들어있다. 연속적인 통신을 위해서는 연결 정보가 필수적이다.

### 세션

HTTP 프로토콜을 사용하는 인터넷 사용자가 웹 사이트를 방문할 때 사용자와 서버 사이 연결을 확인하기 위한 정보이다.

특징

- 서버 내부에 저장된다.
- 저장된 값은 반영구적이다. 브라우저가 종료되면 해당 세션은 폐기된다.
- 사용자가 많아질수록 서버 메모리에 부담이 높아진다. 성능 저하를 유발할 수 있다.
- 클라이언트에게 고유 세션 식별 값을 부여한다.

### 쿠키

클라이언트 내부에 저장되는 작은 데이터 파일이다. 서버 측에서 응답 헤더에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 생성할 수 있다.

특징

- 사용자가 따로 요청하지 않아도 응답 헤더를 통해 자동으로 전송된다.
- 하나의 도메인 당 20개의 값까지 저장할 수 있다. 하나의 쿠키의 최대 용량은 4KB이다.
- 요청 속도가 세션보다 빠르지만 클라이언트 로컬 저장소에 저장되기 때문에 탈취될 위험이 높다.
- 브라우저를 종료해도 계속해서 정보가 남아있다.

속성

- Expires, Max-Age: 쿠키의 수명을 설정한다. 각각 초 단위 또는 시각을 나타내는 문자열로 지정한다.
- Domain: 클라이언트에서 쿠키를 전송할 대상 서버이다.
- Path: 클라이언트에서 쿠키를 전송할 서버의 경로이다.
- Secure: HTTPS의 보안 접속일 때만 클라이언트에서 서버로 보내도록 하는 속성이다. HTTP 접속일 때는 경고를 표시한다.
- HttpOnly: 자바스크립트로부터 쿠키를 보호할 수 있다. XSS 대비
- SameSite: 같은 출처의 도메인에 전송하도록 한다.

### 비연결지향

클라이언트와 서버가 계속해서 연결이 유지하지 않는다는 의미이다. 서버에서는 해당 요청에 대한 응답이 완료되면 즉시 TCP/IP 연결을 종료함으로써 클라이언트 간 연결을 유지하지 않는 것이다. 연결을 계속적으로 유지할 필요가 없기 때문에 서버의 컴퓨팅 자원을 효율적으로 관리하고 대량의 클라이언트의 요청에 대비할 수 있다.

클라이언트가 요청할 때마다 3 Way Handshake 과정을 거쳐야 하는 단점이 있다. Keep-Alive 속성을 통해 응답이 끝나도 클라이언트와의 연결이 유지되도록 할 수 있다.

### 무상태성

서버는 클라이언트의 상태를 저장하지 않는다. 클라이언트가 보냈던 이전의 요청에 따라 응답이 달라지지 않는다. 정보 공유를 최소화할 수 있어서 서버 확장을 용이하게 한다.

## JVM GC 알고리즘

- Mark and Sweep: Root 객체로부터 참조되는 객체를 순회 및 체크한 다음 참조되지 않은 메모리를 해제한다.
- Mark and Compact: Mark and Sweep 이후 남아있는 메모리들을 메모리 주소 앞으로 당겨온다. 메모리 파편화를 예방할 수 있다.

### 메모리 파편화

메모리의 공간이 작은 조각들로 나누어져 전체적인 메모리의 양은 충분하지만 할당이 불가능한 상태를 의미한다.

## OSI 7 계층

정의: 네트워크 프로토콜이 통신하는 구조를 7개의 계층으로 분리하고 각 계층마다 작동하는 방식을 정의한 것이다.

낮은 계층부터 물리 - 데이터 링크 - 네트워크 - 전송 - 세션 - 표현 - 응용 계층으로 이루어진다.

1. 물리 계층

OSI 7 계층에서 최하단 계층이다. 네트워크 데이터가 전송되는 물리적인 매체이다. 데이터는 0과 1의 비트로 나열된 전기적 신호로 이뤄져 있다.

전압, 허브, 네트워크 어댑터, 케이블 등등 모든 하드웨어의 물리적 전기적 특성이 정의된다.

데이터를 디지털에서 아날로그 신호로, 또는 그 반대로 변환하는 역할을 한다.

2. 데이터링크 계층

물리적인 네트워크를 통해 데이터를 전송하는 수단이다. 노드에서 노드 간의 통신을 담당한다. 물리적인 장치를 식별하는데 사용할 수 있는 주소 지정 체계를 제공한다.

물리 계층에서 발생할 수 있는 오류를 찾아내고 교정하기 위한 수단을 제공한다.

브릿지, 스위치, 이더넷 등이 있다.

3. 네트워크 계층

두 개 이상 노드 간의 통신을 담당한다. 실제 네트워크 간의 통신 데이터를 지정된 알고리즘에 의해 최대한 빠르게 보낼 수 있는 최적의 경로를 선택한다. 이 계층은 네트워크 호스트의 논리적인 주소 지정을 확인한다. 데이터 스트림을 더 작은 단위로 분할하고 오류를 감지해서 처리하는 역할도 맡는다.

다양한 길이의 데이터를 전달하고 그 과정에서 전송 계층이 요구하는 서비스 품질을 제공할 수 있는 여러가지 수단을 제공한다.

라우팅, 흐름 제어, 세그멘테이션, 오류 제어 등을 수행한다.

4. 전송 계층

하위 계층에 신뢰할 수 있는 데이터 전송 서비스를 제공한다. 컴퓨터 간의 신뢰성 있는 데이터를 주고받을 수 있도록 한다. 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 한다.

흐름 제어, 분할 및 분리, 오류 제어를 수행한다. 오류 제어는 시퀀스 넘버 기반이다.

주요 프로토콜은 TCP, UDP이다.

5. 세션 계층

두 컴퓨터 간의 대화나 세션을 관리한다. 포트 연결이라고 부른다. TCP/IP 세션을 생성 및 삭제하고 통신하는 사용자들을 동기화하고 오류 복구 명령들을 일괄처리한다. 통신을 하기 위한 세션을 확립하고 유지, 중단하는 작업을 수행한다.

6. 표현 계층

응용 계층으로부터 전달받은 데이터를 읽을 수 있는 형식으로 변환한다. 인코딩, 디코딩이 발생하는 계층이다. 데이터를 안전하게 사용하기 위한 암호화 복호화도 이뤄진다.

7. 응용 계층

사용자가 네트워크 자원에 접근하는 방법을 제시한다. 사용자가 목격할 수 있는 유일한 계층이기도 하다. 모든 네트워크 활동의 기반이 되는 인터페이스를 제공한다.

주요 프로토콜은 텔넷, FTP, SMTP, HTTP가 있다.

## HTTP의 정의

WWW에서 정보를 주고받을 수 있는 프로토콜이다. 주로 HTML 문서를 통신하는데 사용된다. TCP, 또는 HTTP/3에서는 UDP를 사용한다.

클라이언트 및 서버 간 이루어지는 요청, 응답 프로토콜이다. URL로 식별할 수 있다.

### WWW의 정의

인터넷에 연결된 컴퓨터를 통해 사람들이 정보를 공유할 수 있는 일종의 정보 공간이다. 웹이라고도 부른다. 전자 메일처럼 인터넷의 서비스 형태로 작동한다.
