---
title: 'Feedback 003'
description: '몰랐던 지식 정리'
date: 2022-01-24T00:15:18+09:00
image:
math:
license:
hidden: false
comments: true
draft: true
tags:
  [
    '액티비티',
    '프래그먼트',
    '생명주기',
    'Activity',
    'Fragment',
    'Exception',
    'SSL',
    'HTTPS',
    'TLS',
    '데이터베이스',
    '정규화',
    '세션',
    '쿠키',
    'Session',
    'Cookie',
    'Stateless',
    'Stateful',
  ]
categories: ['피드백']
---

# 면접 피드백 003

## 액티비티의 정의

안드로이드 앱이 UI를 출력할 수 있도록 창을 제공하는 기본적인 구성요소이다. 보통 화면을 채우는 일에 사용되지만 다른 창 위에 작게 떠 있도록 할 수도 있다.

## 프래그먼트의 정의

앱 UI에서 재사용 가능한 컴포넌트이다. 자체 레이아웃을 정의 및 관리한다. 각 프래그먼트마다 수명 주기가 존재하며 사용자의 입력 또한 처리할 수 있다. 독립적으로 존재할 수 없고 액티비티나 다른 프래그먼트에서 출력해주도록 호스팅해야한다.

## 코루틴 포착되지 않은 예외 처리

안드로이드에서 네트워크 요청 및 기타 비동기 작업을 처리할 때 코루틴을 사용했다. 코루틴이 실행되는 동안 예상하지 못한 오류가 발생하면 타 코루틴 및 부모 코루틴까지 강제로 종료될 수 있다. 코틀린에서 하위 코루틴들은 각자에게 발생한 예외들을 상위 코루틴이 처리하도록 위임하기 때문이다. 포착되지 못한 예외사항이 발생했을 때 최상위 코루틴에서 예외사항을 처리하기 위해 CoroutineExceptionHandler를 사용할 수 있다.

#### 예시

```Kotlin
// BaseViewModel.kt
open class BaseViewModel : ViewModel() {
    private val coroutineExceptionHandler = CoroutineExceptionHandler { _, throwable ->
        throwable.printStackTrace()
    }

    protected val dispatcher = Dispatchers.Main + coroutineExceptionHandler
}

// 코루틴 실행
viewModelScope.launch(dispatcher) {
  // 비동기 작업
}
```

이 외에도 async 블록 내부에서 try catch 문을 작성하거나, SupervisorScope를 사용해서 예외를 막을 수도 있다. SupervisorScope는 예외가 발생했을 때 예외의 전파 범위를 제한하는 역할을 한다.

## HTTP, TLS

TLS: 전송 계층 암호화 프로토콜

HTTPS 통신 절차

공개 키 암호 방식

1. 브라우저가 서버로부터 서버의 SSL 인증서를 가져온다. 인증서 내부 발행자의 디지털 서명으로부터 상위 발행자의 인증서까지 차례로 검증한다. 최상위 인증기관의 인증서와 브라우저, OS의 인증서로 신뢰할 수 있는지 파악한다.
2. 브라우저는 통신용 공통 키를 생성한다. 서버 인증서에 첨부된 공개 키로 공통 키를 암호화하여 서버에 전송한다. 서버에서는 공개 티에 대응되는 개인 키로 공통 키를 확인할 수 있다.
3. 이후 브라우저와 서버는 공통 키로 메시지를 암호화하여 통신할 수 있다.

키 교환 암호 방식

키를 생성할 시드를 브라우저와 서버 각각 하나씩 만든다. 생성된 시드를 서로 교환 후 계산한 결과가 공통 키가 된다. 시드를 서로 교환할 때 공개 키 암호가 같이 사용된다.  
키 교환 알고리즘으로 생성된 공통 키는 동적으로 계산되고 따로 파일로 저장되지도 않는다.

## 네트워크 연결성

클라이언트와 서버가 요청과 응답을 서로 주고받는 동안 연결이 되어있다는 것을 증명할 수단이 있어야 한다. 연결 정보에는 연결한 사용자가 누구인지, 언제 접속했는지에 대한 정보가 들어있다. 연속적인 통신을 위해서는 연결 정보가 필수적이다.

### 세션

HTTP 프로토콜을 사용하는 인터넷 사용자가 웹 사이트를 방문할 때 사용자와 서버 사이 연결을 확인하기 위한 정보이다.

특징

- 서버 내부에 저장된다.
- 저장된 값은 반영구적이다. 브라우저가 종료되면 해당 세션은 폐기된다.
- 사용자가 많아질수록 서버 메모리에 부담이 높아진다. 성능 저하를 유발할 수 있다.
- 클라이언트에게 고유 세션 식별 값을 부여한다.

### 쿠키

클라이언트 내부에 저장되는 작은 데이터 파일이다. 서버 측에서 응답 헤더에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 생성할 수 있다.

특징

- 사용자가 따로 요청하지 않아도 응답 헤더를 통해 자동으로 전송된다.
- 하나의 도메인 당 20개의 값까지 저장할 수 있다. 하나의 쿠키의 최대 용량은 4KB이다.
- 요청 속도가 세션보다 빠르지만 클라이언트 로컬 저장소에 저장되기 때문에 탈취될 위험이 높다.
- 브라우저를 종료해도 계속해서 정보가 남아있다.

속성

- Expires, Max-Age: 쿠키의 수명을 설정한다. 각각 초 단위 또는 시각을 나타내는 문자열로 지정한다.
- Domain: 클라이언트에서 쿠키를 전송할 대상 서버이다.
- Path: 클라이언트에서 쿠키를 전송할 서버의 경로이다.
- Secure: HTTPS의 보안 접속일 때만 클라이언트에서 서버로 보내도록 하는 속성이다. HTTP 접속일 때는 경고를 표시한다.
- HttpOnly: 자바스크립트로부터 쿠키를 보호할 수 있다. XSS 대비
- SameSite: 같은 출처의 도메인에 전송하도록 한다.

### 비연결지향

클라이언트와 서버가 계속해서 연결이 유지하지 않는다는 의미이다. 서버에서는 해당 요청에 대한 응답이 완료되면 즉시 TCP/IP 연결을 종료함으로써 클라이언트 간 연결을 유지하지 않는 것이다. 연결을 계속적으로 유지할 필요가 없기 때문에 서버의 컴퓨팅 자원을 효율적으로 관리하고 대량의 클라이언트의 요청에 대비할 수 있다.

클라이언트가 요청할 때마다 3 Way Handshake 과정을 거쳐야 하는 단점이 있다. Keep-Alive 속성을 통해 응답이 끝나도 클라이언트와의 연결이 유지되도록 할 수 있다.

### 무상태성

서버는 클라이언트의 상태를 저장하지 않는다. 클라이언트가 보냈던 이전의 요청에 따라 응답이 달라지지 않는다. 정보 공유를 최소화할 수 있어서 서버 확장을 용이하게 한다.

## JVM GC 알고리즘

- Mark and Sweep: Root 객체로부터 참조되는 객체를 순회 및 체크한 다음 참조되지 않은 메모리를 해제한다.
- Mark and Compact: Mark and Sweep 이후 남아있는 메모리들을 메모리 주소 앞으로 당겨온다. 메모리 파편화를 예방할 수 있다.

### 메모리 파편화

메모리의 공간이 작은 조각들로 나누어져 전체적인 메모리의 양은 충분하지만 할당이 불가능한 상태를 의미한다.
